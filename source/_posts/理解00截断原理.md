---
title: 理解%00截断原理
date: 2017-07-03 15:02:50
tags:
- CTF
categories: 
- 漏洞
---


%00截断在以前的 ctf中挺常见的，但是现在也挺尴尬的，很少出现这个小小漏洞了。我又来批判自己了，这个简单原理最近才真正的搞懂了是咋回事，唉，写篇博客查漏补缺，补补自己不懂的地方。

<!--more-->

#### 参考资料：
http://www.tuicool.com/articles/zEVJbiI


#### 原理

划重点 **PHP版本低于5.3.4**

%00截断有这么2种利用状况

1. 在url中加入%00，如http://xxxx/shell.php%00.jpg
2. 在burpsuite的16进制编辑工具将"shell.php .jpg"（带空格的）中间的空格由20改成00  

url中的%00（只要是这种%xx）的形式，webserver会把它当作十六进制处理，然后哦吧16进制的hex自动翻译成ascii码值“NULL”,实现了截断
burpsuite中16进制编辑器将空格20改成了00，跟上面一样的变成asccii的null。


script1.php验证脚本

~~~PHP
<?php
//''不会执行，""会执行
for ($k = 0; $k <= 255; $k++) {
    $a = 'shell.php' . chr($k) . '.jpg';
    echo 'k:' . $k . '    ' . '$a:' . $a . '     ' . 'iconv("utf-8", "gbk", $a)' . iconv("UTF-8", "GBK//ignore", $a) . "<br \>";
//将字符串 $a从 utf8 转换编码到 gbk
}
?>
~~~

在5.3.2的PHP版本下执行这个脚本，其中iconv("UTF-8","gbk",$a)或是iconv("UTF-8","gb2313",$a)都会在chr(128)到chr(255)之间截断，结果就变成shell.php了。
![](https://ooo.0o0.ooo/2017/07/03/5959ed6da5b73.png)

在高于5.3.4的版本下执行会报错，不会出现截断的结果

![](https://ooo.0o0.ooo/2017/07/03/5959ed90332a6.png)








